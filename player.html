<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Player - Streamify</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    .player-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #000;
    }

    #videoPlayer {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    @media (orientation: landscape) {
      #videoPlayer {
        object-fit: cover;
      }
    }

    .player-container:-webkit-full-screen #videoPlayer,
    .player-container:fullscreen #videoPlayer {
      object-fit: cover;
    }

    /* Player Controls */
    .player-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      padding: 20px 30px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      z-index: 10;
      pointer-events: none;
    }

    .player-controls.show {
      opacity: 1;
      visibility: visible;
      pointer-events: all;
    }

    /* On desktop, show on hover */
    @media (min-width: 769px) {
      .player-container:hover .player-controls {
        opacity: 1;
        visibility: visible;
        pointer-events: all;
      }
    }

    /* Progress Bar */
    .progress-container {
      width: 100%;
      height: 5px;
      background: rgba(255,255,255,0.3);
      border-radius: 3px;
      cursor: pointer;
      margin-bottom: 15px;
      position: relative;
    }

    .progress-bar {
      height: 100%;
      background: #e50914;
      border-radius: 3px;
      width: 0%;
      transition: width 0.1s;
    }

    .progress-buffer {
      position: absolute;
      height: 100%;
      background: rgba(255,255,255,0.5);
      border-radius: 3px;
      width: 0%;
    }

    .progress-hover {
      position: absolute;
      bottom: 8px;
      background: rgba(255,255,255,0.9);
      color: #000;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      display: none;
      transform: translateX(-50%);
    }

    .progress-container:hover .progress-hover {
      display: block;
    }

    /* Control Buttons */
    .controls-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 15px;
    }

    .controls-left,
    .controls-right {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .control-btn {
      background: transparent;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
      transition: transform 0.2s;
    }

    .control-btn:hover {
      transform: scale(1.1);
    }

    .control-btn.small {
      font-size: 18px;
    }

    .time-display {
      font-size: 14px;
      color: #fff;
      white-space: nowrap;
    }

    /* Volume Control */
    .volume-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .volume-slider {
      width: 0;
      opacity: 0;
      transition: all 0.3s;
    }

    .volume-control:hover .volume-slider {
      width: 80px;
      opacity: 1;
    }

    input[type="range"] {
      height: 4px;
      background: rgba(255,255,255,0.3);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Settings Menu */
    .settings-menu {
      position: absolute;
      bottom: 80px;
      right: 30px;
      background: rgba(0,0,0,0.95);
      border-radius: 8px;
      padding: 10px 0;
      min-width: 200px;
      display: none;
      z-index: 20;
    }

    .settings-menu.show {
      display: block;
    }

    .settings-item {
      padding: 12px 20px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }

    .settings-item:hover {
      background: rgba(255,255,255,0.1);
    }

    .settings-submenu {
      position: absolute;
      right: 100%;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      border-radius: 8px;
      padding: 10px 0;
      min-width: 150px;
      display: none;
      margin-right: 5px;
      max-height: 300px;
      overflow-y: auto;
    }

    .settings-submenu.show {
      display: block;
    }

    .settings-item {
      position: relative;
    }

    /* Top Controls */
    .top-controls {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(rgba(0,0,0,0.8), transparent);
      padding: 20px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      z-index: 10;
      pointer-events: none;
    }

    .top-controls.show {
      opacity: 1;
      visibility: visible;
      pointer-events: all;
    }

    /* On desktop, show on hover */
    @media (min-width: 769px) {
      .player-container:hover .top-controls {
        opacity: 1;
        visibility: visible;
        pointer-events: all;
      }
    }

    .episode-info h3 {
      font-size: 20px;
      margin-bottom: 5px;
    }

    .episode-meta {
      font-size: 14px;
      color: rgba(255,255,255,0.7);
    }

    .back-btn {
      background: transparent;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
    }

    /* Episode Navigation Overlay - REMOVED */
    /* No longer needed as navigation is in control bar */

    /* Loading Spinner */
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255,255,255,0.3);
      border-top: 4px solid #e50914;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }

    .loading-spinner.show {
      display: block;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* Center Play Button */
    .center-play {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.3);
      border: 3px solid #fff;
      border-radius: 50%;
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s;
      z-index: 5;
    }

    .center-play.show {
      opacity: 1;
    }

    .center-play:hover {
      background: rgba(229,9,20,0.8);
      transform: translate(-50%, -50%) scale(1.1);
    }

    .center-play i {
      font-size: 32px;
      margin-left: 5px;
    }

    /* Skip Intro/Credits */
    .skip-button {
      position: absolute;
      bottom: 100px;
      right: 30px;
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.5);
      color: #fff;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      display: none;
      z-index: 10;
    }

    .skip-button.show {
      display: block;
    }

    .skip-button:hover {
      background: rgba(255,255,255,0.3);
    }

    /* Mobile Adjustments */
    @media (max-width: 768px) {
      .player-controls {
        padding: 15px 20px;
      }

      .control-btn {
        font-size: 20px;
      }

      .time-display {
        font-size: 12px;
      }

      .episode-nav-overlay {
        width: 50px;
        height: 50px;
      }

      .prev-episode {
        left: 15px;
      }

      .next-episode {
        right: 15px;
      }

      .settings-menu {
        right: 10px;
        bottom: 70px;
      }

      .volume-control:hover .volume-slider {
        width: 60px;
      }
    }

    /* Episodes List */
    .episodes-list-overlay {
      position: fixed;
      top: 0;
      right: 0;
      width: 400px;
      max-width: 100%;
      height: 100vh;
      background: rgba(0,0,0,0.95);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 25;
      overflow-y: auto;
      padding: 20px;
    }

    .episodes-list-overlay.show {
      transform: translateX(0);
    }

    .episodes-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }

    .episodes-header h3 {
      font-size: 20px;
    }

    .close-episodes-btn {
      background: transparent;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }

    .episode-card {
      display: flex;
      gap: 10px;
      padding: 10px;
      margin-bottom: 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
    }

    .episode-card:hover {
      background: rgba(255,255,255,0.1);
    }

    .episode-card.active {
      border-color: #e50914;
      background: rgba(229,9,20,0.1);
    }

    .episode-card-thumb {
      width: 120px;
      height: 68px;
      border-radius: 4px;
      object-fit: cover;
      flex-shrink: 0;
    }

    .episode-card-info {
      flex: 1;
      min-width: 0;
    }

    .episode-card-number {
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 4px;
    }

    .episode-card-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .episode-card-duration {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
    }

    @media (max-width: 768px) {
      .episodes-list-overlay {
        width: 100%;
      }
    }

    /* Touch feedback */
    .touch-feedback {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 20px;
      border-radius: 50%;
      font-size: 32px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
    }

    .touch-feedback.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="player-container" id="playerContainer">
    <video id="videoPlayer" playsinline></video>
    
    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loadingSpinner"></div>

    <!-- Center Play Button -->
    <div class="center-play" id="centerPlay">
      <i class="fas fa-play"></i>
    </div>

    <!-- Top Controls -->
    <div class="top-controls" id="topControls">
      <button class="back-btn" id="backBtn">
        <i class="fas fa-arrow-left"></i>
      </button>
      <div class="episode-info">
        <h3 id="episodeTitle">Episode Title</h3>
        <div class="episode-meta" id="episodeMeta">Season 1 • Episode 1</div>
      </div>
      <div></div>
    </div>

    <!-- Episode Navigation -->
    <div class="episode-nav-overlay prev-episode" id="prevEpisode">
      <i class="fas fa-step-backward"></i>
    </div>
    <div class="episode-nav-overlay next-episode" id="nextEpisode">
      <i class="fas fa-step-forward"></i>
    </div>

    <!-- Skip Button -->
    <button class="skip-button" id="skipButton">Skip Intro</button>

    <!-- Episodes List -->
    <div class="episodes-list-overlay" id="episodesListOverlay">
      <div class="episodes-header">
        <h3>Episodes</h3>
        <button class="close-episodes-btn" id="closeEpisodesBtn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div id="episodesList"></div>
    </div>

    <!-- Touch Feedback -->
    <div class="touch-feedback" id="touchFeedback">
      <i class="fas fa-play"></i>
    </div>

    <!-- Player Controls -->
    <div class="player-controls" id="playerControls">
      <!-- Progress Bar -->
      <div class="progress-container" id="progressContainer">
        <div class="progress-buffer" id="progressBuffer"></div>
        <div class="progress-bar" id="progressBar"></div>
        <div class="progress-hover" id="progressHover">0:00</div>
      </div>

      <!-- Control Buttons -->
      <div class="controls-row">
        <div class="controls-left">
          <button class="control-btn small" id="prevEpisodeBtn" title="Previous Episode">
            <i class="fas fa-step-backward"></i>
          </button>
          <button class="control-btn" id="playPauseBtn">
            <i class="fas fa-play"></i>
          </button>
          <button class="control-btn small" id="nextEpisodeBtn" title="Next Episode">
            <i class="fas fa-step-forward"></i>
          </button>
          <button class="control-btn small" id="skipBackBtn">
            <i class="fas fa-rotate-left"></i>
          </button>
          <button class="control-btn small" id="skipForwardBtn">
            <i class="fas fa-rotate-right"></i>
          </button>
          <div class="volume-control">
            <button class="control-btn small" id="volumeBtn">
              <i class="fas fa-volume-up"></i>
            </button>
            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100">
          </div>
          <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
        </div>

        <div class="controls-right">
          <button class="control-btn small" id="episodesBtn">
            <i class="fas fa-list"></i>
          </button>
          <button class="control-btn small" id="settingsBtn">
            <i class="fas fa-cog"></i>
          </button>
          <button class="control-btn small" id="fullscreenBtn">
            <i class="fas fa-expand"></i>
          </button>
        </div>
      </div>
    </div>

    <!-- Settings Menu -->
    <div class="settings-menu" id="settingsMenu">
      <div class="settings-item" id="speedMenu">
        Speed <span id="currentSpeed">1x</span>
      </div>
      <div class="settings-item" id="qualityMenu">
        Quality <span id="currentQuality">Auto</span>
      </div>
      <div class="settings-item" id="audioMenu">
        Audio <span id="currentAudio">Default</span>
      </div>
      <div class="settings-item" id="subtitleMenu">
        Subtitles <span id="currentSubtitle">Off</span>
      </div>
      <div class="settings-item" id="fitMenu">
        Video Fit <span id="currentFit">Contain</span>
      </div>
    </div>
  </div>

  <script>
    class NetflixPlayer {
      constructor() {
        this.video = document.getElementById('videoPlayer');
        this.hls = null;
        this.currentEpisode = null;
        this.episodes = [];
        this.showId = null;
        this.continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');
        this.settings = JSON.parse(localStorage.getItem('playerSettings') || '{"defaultAudioLang":"auto","defaultQuality":"-1","defaultSubtitle":"none"}');
        this.controlsTimeout = null;
        this.isPlaying = false;
        this.qualitySetup = false;
        this.touchStartX = 0;
        this.touchStartY = 0;
        this.touchStartTime = 0;
        this.isSeeking = false;
        this.isFullscreen = false;
        
        this.init();
      }

      async init() {
        const params = new URLSearchParams(window.location.search);
        this.showId = params.get('showId');
        const episodeId = params.get('episodeId');

        if (!this.showId || !episodeId) {
          alert('Invalid player parameters');
          window.history.back();
          return;
        }

        try {
          const response = await fetch('tvshows.json');
          const data = await response.json();
          const show = data.find(s => s.id === this.showId);
          
          if (!show) {
            throw new Error('Show not found');
          }

          this.episodes = show.items.filter(i => i.type === 'episode').sort((a, b) => a.sequence - b.sequence);
          this.currentEpisode = this.episodes.find(ep => ep.id === episodeId);

          if (!this.currentEpisode) {
            throw new Error('Episode not found');
          }

          this.loadEpisode();
          this.setupEventListeners();
          this.setupKeyboardShortcuts();
          this.setupMobileSupport();
          this.renderEpisodesList();
        } catch (error) {
          console.error('Init error:', error);
          alert('Failed to load episode');
          window.history.back();
        }
      }

      loadEpisode() {
        document.getElementById('loadingSpinner').classList.add('show');
        
        const title = this.currentEpisode.title || `Episode ${this.currentEpisode.sequence}`;
        const seasonNum = this.currentEpisode.container?.title?.match(/\d+/)?.[0] || '1';
        const duration = this.formatTime(parseInt(this.currentEpisode.duration || 0));
        
        document.getElementById('episodeTitle').textContent = title;
        document.getElementById('episodeMeta').textContent = `Season ${seasonNum} • Episode ${this.currentEpisode.sequence} • ${duration}`;

        const hlsUrl = this.currentEpisode.stream?.hls?.high || this.currentEpisode.stream?.thirdParty?.hlsUrl;
        const poster = this.currentEpisode.imageInfo?.find(i => i.type === 'bigpic')?.url || '';

        if (poster) this.video.poster = poster;

        if (Hls.isSupported()) {
          if (this.hls) {
            this.hls.destroy();
          }

          this.hls = new Hls({
            enableWebVTT: true,
            capLevelToPlayerSize: true
          });

          this.hls.loadSource(hlsUrl);
          this.hls.attachMedia(this.video);

          this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
            document.getElementById('loadingSpinner').classList.remove('show');
            this.restoreContinueWatching();
            this.video.play();
          });

          this.hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, () => {
            this.setupAudio();
            this.applyDefaultAudio();
          });

          this.hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, () => {
            this.setupSubtitles();
            this.applyDefaultSubtitles();
          });

          this.hls.on(Hls.Events.LEVEL_LOADED, () => {
            if (!this.qualitySetup) {
              this.setupQuality();
              this.applyDefaultQuality();
              this.qualitySetup = true;
            }
          });

          this.hls.on(Hls.Events.ERROR, (event, data) => {
            if (data.fatal) {
              console.error('HLS Error:', data);
              document.getElementById('loadingSpinner').classList.remove('show');
            }
          });
        } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {
          this.video.src = hlsUrl;
          this.video.load();
          this.restoreContinueWatching();
          this.video.play();
        }

        this.updateNavigation();
      }

      renderEpisodesList() {
        const container = document.getElementById('episodesList');
        container.innerHTML = '';

        // Get current season episodes
        const currentSeasonNum = this.currentEpisode.container?.title?.match(/\d+/)?.[0] || '1';
        const seasonEpisodes = this.episodes.filter(ep => {
          const seasonNum = ep.container?.title?.match(/\d+/)?.[0] || '1';
          return seasonNum === currentSeasonNum;
        });

        seasonEpisodes.forEach(episode => {
          const card = document.createElement('div');
          card.className = `episode-card ${episode.id === this.currentEpisode.id ? 'active' : ''}`;
          
          const thumbnail = episode.imageInfo?.find(i => i.type === 'bigpic')?.url || 
                           'https://via.placeholder.com/120x68/333/fff?text=Episode';
          const title = episode.title || `Episode ${episode.sequence}`;
          const duration = this.formatTime(parseInt(episode.duration || 0));

          card.innerHTML = `
            <img class="episode-card-thumb" src="${thumbnail}" alt="${title}">
            <div class="episode-card-info">
              <div class="episode-card-number">Episode ${episode.sequence}</div>
              <div class="episode-card-title">${title}</div>
              <div class="episode-card-duration">${duration}</div>
            </div>
          `;

          card.onclick = () => {
            if (episode.id !== this.currentEpisode.id) {
              window.location.href = `player.html?showId=${this.showId}&episodeId=${episode.id}`;
            }
          };

          container.appendChild(card);
        });
      }

      restoreContinueWatching() {
        const continueData = this.continueWatching[this.showId];
        if (continueData && continueData.episodeId === this.currentEpisode.id && continueData.currentTime > 30) {
          this.video.currentTime = continueData.currentTime;
        }
      }

      saveContinueWatching() {
        if (this.video.currentTime > 30 && this.video.duration > 0) {
          const container = this.currentEpisode?.container?.container || {};
          const portraitImg = container?.imageInfo?.find(img => img.type === 'portrait_large')?.url || '';
          const showTitle = container?.title || 'Untitled Show';
          const seasonNum = this.currentEpisode.container?.title?.match(/\d+/)?.[0] || '1';

          if (this.video.currentTime / this.video.duration >= 0.95) {
            delete this.continueWatching[this.showId];
          } else {
            this.continueWatching[this.showId] = {
              episodeId: this.currentEpisode.id,
              episodeTitle: this.currentEpisode.title || `Episode ${this.currentEpisode.sequence}`,
              episodeNum: this.currentEpisode.sequence,
              seasonNum: seasonNum,
              currentTime: this.video.currentTime,
              duration: this.video.duration,
              showTitle: showTitle,
              thumbnail: portraitImg,
              timestamp: Date.now()
            };
          }

          localStorage.setItem('continueWatching', JSON.stringify(this.continueWatching));
        }
      }

      setupQuality() {
        if (!this.hls || this.hls.levels.length <= 1) return;

        const qualityMenu = document.getElementById('qualityMenu');
        const submenu = document.createElement('div');
        submenu.className = 'settings-submenu';

        const autoOption = document.createElement('div');
        autoOption.className = 'settings-item';
        autoOption.textContent = 'Auto';
        autoOption.onclick = () => {
          this.hls.currentLevel = -1;
          document.getElementById('currentQuality').textContent = 'Auto';
          submenu.classList.remove('show');
          document.getElementById('settingsMenu').classList.remove('show');
        };
        submenu.appendChild(autoOption);

        this.hls.levels.forEach((level, i) => {
          const option = document.createElement('div');
          option.className = 'settings-item';
          option.textContent = `${level.height}p`;
          option.onclick = () => {
            this.hls.currentLevel = i;
            document.getElementById('currentQuality').textContent = `${level.height}p`;
            submenu.classList.remove('show');
            document.getElementById('settingsMenu').classList.remove('show');
          };
          submenu.appendChild(option);
        });

        qualityMenu.appendChild(submenu);
        qualityMenu.onmouseenter = () => submenu.classList.add('show');
        qualityMenu.onmouseleave = () => setTimeout(() => submenu.classList.remove('show'), 200);
        submenu.onmouseenter = () => submenu.classList.add('show');
        submenu.onmouseleave = () => submenu.classList.remove('show');
      }

      applyDefaultQuality() {
        if (!this.hls || !this.settings.defaultQuality || this.settings.defaultQuality === "-1") {
          this.hls.currentLevel = -1;
          document.getElementById('currentQuality').textContent = 'Auto';
          return;
        }

        const preferredHeight = parseInt(this.settings.defaultQuality);
        const preferredLevelIndex = this.hls.levels.findIndex(level => level.height === preferredHeight);
        
        if (preferredLevelIndex !== -1) {
          this.hls.currentLevel = preferredLevelIndex;
          document.getElementById('currentQuality').textContent = `${preferredHeight}p`;
        } else {
          this.hls.currentLevel = -1;
          document.getElementById('currentQuality').textContent = 'Auto';
        }
      }

      setupAudio() {
        const audioMenu = document.getElementById('audioMenu');
        
        // Remove existing submenu if any
        const existingSubmenu = audioMenu.querySelector('.settings-submenu');
        if (existingSubmenu) {
          existingSubmenu.remove();
        }

        if (!this.hls || this.hls.audioTracks.length <= 1) {
          document.getElementById('currentAudio').textContent = 'Default';
          return;
        }

        const submenu = document.createElement('div');
        submenu.className = 'settings-submenu';

        const langMap = {
          'ta': 'Tamil', 'te': 'Telugu', 'hi': 'Hindi', 'en': 'English',
          'ko': 'Korean', 'zh': 'Chinese', 'ja': 'Japanese'
        };

        this.hls.audioTracks.forEach((track, i) => {
          const option = document.createElement('div');
          option.className = 'settings-item';
          const langName = langMap[track.lang] || track.name || `Audio ${i + 1}`;
          option.textContent = langName;
          option.onclick = () => {
            this.hls.audioTrack = i;
            document.getElementById('currentAudio').textContent = langName;
            submenu.classList.remove('show');
            document.getElementById('settingsMenu').classList.remove('show');
          };
          submenu.appendChild(option);
        });

        audioMenu.appendChild(submenu);
        audioMenu.onmouseenter = () => submenu.classList.add('show');
        audioMenu.onmouseleave = () => setTimeout(() => submenu.classList.remove('show'), 200);
        submenu.onmouseenter = () => submenu.classList.add('show');
        submenu.onmouseleave = () => submenu.classList.remove('show');
      }

      applyDefaultAudio() {
        if (!this.hls || this.hls.audioTracks.length === 0) return;

        const langMap = {
          'ta': 'Tamil', 'te': 'Telugu', 'hi': 'Hindi', 'en': 'English',
          'ko': 'Korean', 'zh': 'Chinese', 'ja': 'Japanese'
        };

        // Apply default audio language from settings
        if (this.settings.defaultAudioLang && this.settings.defaultAudioLang !== 'auto') {
          const preferredLang = this.settings.defaultAudioLang;
          let selectedIndex = this.hls.audioTracks.findIndex(track => track.lang === preferredLang);

          // Fallback logic for Tamil
          if (selectedIndex === -1 && preferredLang === 'ta') {
            const fallbackLangs = ['zh', 'ko', 'ja'];
            for (let lang of fallbackLangs) {
              selectedIndex = this.hls.audioTracks.findIndex(track => track.lang === lang);
              if (selectedIndex !== -1) break;
            }
          }

          if (selectedIndex !== -1) {
            this.hls.audioTrack = selectedIndex;
            const track = this.hls.audioTracks[selectedIndex];
            const langName = langMap[track.lang] || track.name || `Audio ${selectedIndex + 1}`;
            document.getElementById('currentAudio').textContent = langName;
          } else {
            // Use first available track
            this.hls.audioTrack = 0;
            const track = this.hls.audioTracks[0];
            const langName = langMap[track.lang] || track.name || 'Audio 1';
            document.getElementById('currentAudio').textContent = langName;
          }
        } else {
          // Auto mode - use first available
          if (this.hls.audioTracks.length > 0) {
            this.hls.audioTrack = 0;
            const track = this.hls.audioTracks[0];
            const langName = langMap[track.lang] || track.name || 'Audio 1';
            document.getElementById('currentAudio').textContent = langName;
          }
        }
      }

      setupSubtitles() {
        const subtitleMenu = document.getElementById('subtitleMenu');
        
        // Remove existing submenu if any
        const existingSubmenu = subtitleMenu.querySelector('.settings-submenu');
        if (existingSubmenu) {
          existingSubmenu.remove();
        }

        const submenu = document.createElement('div');
        submenu.className = 'settings-submenu';

        const noneOption = document.createElement('div');
        noneOption.className = 'settings-item';
        noneOption.textContent = 'Off';
        noneOption.onclick = () => {
          if (this.hls) this.hls.subtitleTrack = -1;
          document.getElementById('currentSubtitle').textContent = 'Off';
          submenu.classList.remove('show');
          document.getElementById('settingsMenu').classList.remove('show');
        };
        submenu.appendChild(noneOption);

        if (this.hls && this.hls.subtitleTracks.length > 0) {
          this.hls.subtitleTracks.forEach((track, i) => {
            const option = document.createElement('div');
            option.className = 'settings-item';
            option.textContent = track.name || `Subtitles ${i + 1}`;
            option.onclick = () => {
              this.hls.subtitleTrack = i;
              document.getElementById('currentSubtitle').textContent = option.textContent;
              submenu.classList.remove('show');
              document.getElementById('settingsMenu').classList.remove('show');
            };
            submenu.appendChild(option);
          });
        }

        subtitleMenu.appendChild(submenu);
        subtitleMenu.onmouseenter = () => submenu.classList.add('show');
        subtitleMenu.onmouseleave = () => setTimeout(() => submenu.classList.remove('show'), 200);
        submenu.onmouseenter = () => submenu.classList.add('show');
        submenu.onmouseleave = () => submenu.classList.remove('show');
      }

      applyDefaultSubtitles() {
        if (!this.hls) return;

        // Apply default subtitle setting from settings
        if (this.settings.defaultSubtitle === 'none' || !this.settings.defaultSubtitle) {
          this.hls.subtitleTrack = -1;
          document.getElementById('currentSubtitle').textContent = 'Off';
          return;
        }

        if (this.settings.defaultSubtitle === 'english' && this.hls.subtitleTracks.length > 0) {
          const englishTrack = this.hls.subtitleTracks.findIndex(track =>
            (track.name?.toLowerCase().includes('english') || track.lang === 'en')
          );
          
          if (englishTrack !== -1) {
            this.hls.subtitleTrack = englishTrack;
            const track = this.hls.subtitleTracks[englishTrack];
            document.getElementById('currentSubtitle').textContent = track.name || 'English';
          } else {
            this.hls.subtitleTrack = -1;
            document.getElementById('currentSubtitle').textContent = 'Off';
          }
        } else {
          this.hls.subtitleTrack = -1;
          document.getElementById('currentSubtitle').textContent = 'Off';
        }
      }

      setupEventListeners() {
        // Play/Pause
        document.getElementById('playPauseBtn').onclick = () => this.togglePlay();
        document.getElementById('centerPlay').onclick = () => this.togglePlay();
        this.video.onclick = () => this.togglePlay();

        // Progress bar
        const progressContainer = document.getElementById('progressContainer');
        progressContainer.onclick = (e) => this.seek(e);
        progressContainer.onmousemove = (e) => this.showProgressHover(e);

        // Skip buttons
        document.getElementById('skipBackBtn').onclick = () => this.video.currentTime -= 10;
        document.getElementById('skipForwardBtn').onclick = () => this.video.currentTime += 10;

        // Episode navigation
        document.getElementById('prevEpisodeBtn').onclick = () => this.playPrevious();
        document.getElementById('nextEpisodeBtn').onclick = () => this.playNext();

        // Volume
        document.getElementById('volumeBtn').onclick = () => this.toggleMute();
        document.getElementById('volumeSlider').oninput = (e) => this.video.volume = e.target.value / 100;

        // Fullscreen
        document.getElementById('fullscreenBtn').onclick = () => this.toggleFullscreen();

        // Settings
        document.getElementById('settingsBtn').onclick = () => {
          document.getElementById('settingsMenu').classList.toggle('show');
        };

        // Episodes list
        document.getElementById('episodesBtn').onclick = () => {
          document.getElementById('episodesListOverlay').classList.toggle('show');
        };

        document.getElementById('closeEpisodesBtn').onclick = () => {
          document.getElementById('episodesListOverlay').classList.remove('show');
        };

        // Speed control
        this.setupSpeedControl();

        // Video fit
        this.setupVideoFit();

        // Navigation (desktop hover only)
        document.getElementById('backBtn').onclick = () => {
          window.location.href = `tvplayer.html?id=${this.showId}`;
        };
        
        // Remove old overlay navigation buttons since they're removed from HTML
        // const prevOverlay = document.getElementById('prevEpisode');
        // const nextOverlay = document.getElementById('nextEpisode');
        // if (prevOverlay) prevOverlay.onclick = () => this.playPrevious();
        // if (nextOverlay) nextOverlay.onclick = () => this.playNext();

        // Video events
        this.video.ontimeupdate = () => this.updateProgress();
        this.video.onpause = () => this.onPause();
        this.video.onplay = () => this.onPlay();
        this.video.onended = () => this.onEnded();
        this.video.onprogress = () => this.updateBuffer();

        // Auto-hide controls
        this.playerContainer = document.getElementById('playerContainer');
        
        // Show controls initially for 3 seconds
        this.showControls();
        setTimeout(() => {
          if (this.isPlaying) {
            this.hideControls();
          }
        }, 3000);
        
        // Desktop: show on mouse move
        this.playerContainer.addEventListener('mousemove', () => {
          if (window.innerWidth > 768) {
            this.showControls();
          }
        });

        // Mobile: show on touch
        this.playerContainer.addEventListener('touchstart', () => {
          // Only show controls if user taps, not during swipes
          this.touchInteractionStart = Date.now();
        });

        this.playerContainer.addEventListener('touchend', (e) => {
          const touchDuration = Date.now() - this.touchInteractionStart;
          // If it was a quick tap (not a long press or swipe)
          if (touchDuration < 200) {
            // Toggle controls visibility
            const controls = document.getElementById('playerControls');
            if (controls.classList.contains('show')) {
              this.hideControls();
            } else {
              this.showControls();
            }
          }
        });

        // Fullscreen change listener
        document.addEventListener('fullscreenchange', () => {
          this.isFullscreen = !!document.fullscreenElement;
          this.updateVideoFitForOrientation();
        });

        document.addEventListener('webkitfullscreenchange', () => {
          this.isFullscreen = !!document.webkitFullscreenElement;
          this.updateVideoFitForOrientation();
        });

        // Orientation change listener
        window.addEventListener('orientationchange', () => {
          setTimeout(() => this.updateVideoFitForOrientation(), 100);
        });

        // Save progress periodically
        document.addEventListener('fullscreenchange', () => {
          this.isFullscreen = !!document.fullscreenElement;
          this.updateVideoFitForOrientation();
        });

        document.addEventListener('webkitfullscreenchange', () => {
          this.isFullscreen = !!document.webkitFullscreenElement;
          this.updateVideoFitForOrientation();
        });

        // Orientation change listener
        window.addEventListener('orientationchange', () => {
          setTimeout(() => this.updateVideoFitForOrientation(), 100);
        });

        // Save progress periodically
        setInterval(() => this.saveContinueWatching(), 5000);
      }

      setupSpeedControl() {
        const speedMenu = document.getElementById('speedMenu');
        const submenu = document.createElement('div');
        submenu.className = 'settings-submenu';

        [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2].forEach(speed => {
          const option = document.createElement('div');
          option.className = 'settings-item';
          option.textContent = `${speed}x`;
          option.onclick = () => {
            this.video.playbackRate = speed;
            document.getElementById('currentSpeed').textContent = `${speed}x`;
            submenu.classList.remove('show');
          };
          submenu.appendChild(option);
        });

        speedMenu.appendChild(submenu);
        speedMenu.onmouseenter = () => submenu.classList.add('show');
        speedMenu.onmouseleave = () => setTimeout(() => submenu.classList.remove('show'), 200);
        submenu.onmouseenter = () => submenu.classList.add('show');
        submenu.onmouseleave = () => submenu.classList.remove('show');
      }

      setupVideoFit() {
        const fitMenu = document.getElementById('fitMenu');
        const submenu = document.createElement('div');
        submenu.className = 'settings-submenu';

        const fits = {
          'contain': 'Fit to Screen',
          'cover': 'Zoom to Fill',
          'fill': 'Stretch',
          'none': 'Original Size'
        };

        // Set initial fit based on orientation
        this.updateVideoFitForOrientation();

        Object.entries(fits).forEach(([value, label]) => {
          const option = document.createElement('div');
          option.className = 'settings-item';
          option.textContent = label;
          option.onclick = () => {
            this.video.style.objectFit = value;
            document.getElementById('currentFit').textContent = label;
            submenu.classList.remove('show');
            document.getElementById('settingsMenu').classList.remove('show');
          };
          submenu.appendChild(option);
        });

        fitMenu.appendChild(submenu);
        fitMenu.onmouseenter = () => submenu.classList.add('show');
        fitMenu.onmouseleave = () => setTimeout(() => submenu.classList.remove('show'), 200);
        submenu.onmouseenter = () => submenu.classList.add('show');
        submenu.onmouseleave = () => submenu.classList.remove('show');
      }

      updateVideoFitForOrientation() {
        // In fullscreen or landscape, use cover (zoom to fill)
        if (this.isFullscreen || window.innerWidth > window.innerHeight) {
          this.video.style.objectFit = 'cover';
          document.getElementById('currentFit').textContent = 'Zoom to Fill';
        } else {
          // In portrait mode, use contain (fit to screen)
          this.video.style.objectFit = 'contain';
          document.getElementById('currentFit').textContent = 'Fit to Screen';
        }
      }

      setupMobileSupport() {
        let lastTap = 0;
        let doubleTapTimer = null;
        this.touchInteractionStart = 0;

        // Touch events for seeking and play/pause
        this.video.addEventListener('touchstart', (e) => {
          this.touchStartX = e.touches[0].clientX;
          this.touchStartY = e.touches[0].clientY;
          this.touchStartTime = Date.now();
        });

        this.video.addEventListener('touchmove', (e) => {
          if (this.isSeeking) {
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            const deltaX = touchX - this.touchStartX;
            
            // Seek based on horizontal swipe
            if (Math.abs(deltaX) > 10) {
              const seekAmount = deltaX / 5;
              this.video.currentTime += seekAmount / 10;
              this.touchStartX = touchX;
              this.showTouchFeedback(seekAmount > 0 ? 'forward' : 'backward');
            }
          }
        });

        this.video.addEventListener('touchend', (e) => {
          const touchDuration = Date.now() - this.touchStartTime;
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          const deltaX = Math.abs(touchEndX - this.touchStartX);
          const deltaY = Math.abs(touchEndY - this.touchStartY);

          // If it was a tap (not a swipe)
          if (touchDuration < 300 && deltaX < 10 && deltaY < 10) {
            const now = Date.now();
            const timeSinceLastTap = now - lastTap;

            if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
              // Double tap detected
              clearTimeout(doubleTapTimer);
              const screenWidth = window.innerWidth;
              const tapX = touchEndX;

              if (tapX < screenWidth / 3) {
                // Left side - rewind 10s
                this.video.currentTime -= 10;
                this.showTouchFeedback('backward');
                
                // Show controls briefly, then hide
                this.showControls();
                setTimeout(() => {
                  if (this.isPlaying) {
                    this.hideControls();
                  }
                }, 1000);
              } else if (tapX > (screenWidth * 2) / 3) {
                // Right side - forward 10s
                this.video.currentTime += 10;
                this.showTouchFeedback('forward');
                
                // Show controls briefly, then hide
                this.showControls();
                setTimeout(() => {
                  if (this.isPlaying) {
                    this.hideControls();
                  }
                }, 1000);
              } else {
                // Center - play/pause
                this.togglePlay();
              }
              lastTap = 0;
            } else {
              // Single tap
              lastTap = now;
              doubleTapTimer = setTimeout(() => {
                const screenWidth = window.innerWidth;
                const tapX = touchEndX;
                
                // Only center tap toggles controls
                if (tapX > screenWidth / 3 && tapX < (screenWidth * 2) / 3) {
                  const controls = document.getElementById('playerControls');
                  if (controls.classList.contains('show')) {
                    this.hideControls();
                  } else {
                    this.showControls();
                  }
                }
                // Left/right single tap does nothing
              }, 300);
            }
          }

          this.isSeeking = false;
        });

        // Prevent context menu on long press
        this.video.addEventListener('contextmenu', (e) => {
          e.preventDefault();
        });

        // Swipe gestures for episode navigation
        let swipeStartX = 0;
        this.playerContainer.addEventListener('touchstart', (e) => {
          if (e.target !== this.video) {
            swipeStartX = e.touches[0].clientX;
          }
        });

        this.playerContainer.addEventListener('touchend', (e) => {
          if (e.target !== this.video) {
            const swipeEndX = e.changedTouches[0].clientX;
            const swipeDistance = swipeEndX - swipeStartX;

            if (Math.abs(swipeDistance) > 100) {
              if (swipeDistance > 0) {
                // Swipe right - previous episode
                this.playPrevious();
              } else {
                // Swipe left - next episode
                this.playNext();
              }
            }
          }
        });
      }

      showTouchFeedback(type) {
        const feedback = document.getElementById('touchFeedback');
        const icon = feedback.querySelector('i');
        
        if (type === 'forward') {
          icon.className = 'fas fa-forward';
        } else if (type === 'backward') {
          icon.className = 'fas fa-backward';
        } else {
          icon.className = 'fas fa-play';
        }

        feedback.classList.add('show');
        setTimeout(() => {
          feedback.classList.remove('show');
        }, 500);
      }

      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT') return;

          switch(e.key) {
            case ' ':
            case 'k':
              e.preventDefault();
              this.togglePlay();
              break;
            case 'ArrowLeft':
            case 'j':
              e.preventDefault();
              this.video.currentTime -= 10;
              break;
            case 'ArrowRight':
            case 'l':
              e.preventDefault();
              this.video.currentTime += 10;
              break;
            case 'f':
              e.preventDefault();
              this.toggleFullscreen();
              break;
            case 'm':
              e.preventDefault();
              this.toggleMute();
              break;
            case 'ArrowUp':
              e.preventDefault();
              this.video.volume = Math.min(1, this.video.volume + 0.1);
              break;
            case 'ArrowDown':
              e.preventDefault();
              this.video.volume = Math.max(0, this.video.volume - 0.1);
              break;
            case 'n':
              e.preventDefault();
              this.playNext();
              break;
            case 'p':
              e.preventDefault();
              this.playPrevious();
              break;
          }
        });
      }

      togglePlay() {
        if (this.video.paused) {
          this.video.play();
        } else {
          this.video.pause();
        }
      }

      onPlay() {
        this.isPlaying = true;
        document.getElementById('centerPlay').classList.remove('show');
        document.getElementById('playPauseBtn').innerHTML = '<i class="fas fa-pause"></i>';
      }

      onPause() {
        this.isPlaying = false;
        document.getElementById('centerPlay').classList.add('show');
        document.getElementById('playPauseBtn').innerHTML = '<i class="fas fa-play"></i>';
      }

      onEnded() {
        this.saveContinueWatching();
        setTimeout(() => this.playNext(), 2000);
      }

      updateProgress() {
        const percent = (this.video.currentTime / this.video.duration) * 100;
        document.getElementById('progressBar').style.width = `${percent}%`;
        
        const currentTime = this.formatTime(this.video.currentTime);
        const duration = this.formatTime(this.video.duration);
        document.getElementById('timeDisplay').textContent = `${currentTime} / ${duration}`;
      }

      updateBuffer() {
        if (this.video.buffered.length > 0) {
          const bufferedEnd = this.video.buffered.end(this.video.buffered.length - 1);
          const percent = (bufferedEnd / this.video.duration) * 100;
          document.getElementById('progressBuffer').style.width = `${percent}%`;
        }
      }

      seek(e) {
        const rect = e.currentTarget.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        this.video.currentTime = percent * this.video.duration;
      }

      showProgressHover(e) {
        const rect = e.currentTarget.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const time = percent * this.video.duration;
        const hover = document.getElementById('progressHover');
        hover.textContent = this.formatTime(time);
        hover.style.left = `${e.clientX - rect.left}px`;
      }

      toggleMute() {
        this.video.muted = !this.video.muted;
        const icon = document.getElementById('volumeBtn').querySelector('i');
        icon.className = this.video.muted ? 'fas fa-volume-mute' : 'fas fa-volume-up';
        document.getElementById('volumeSlider').value = this.video.muted ? 0 : this.video.volume * 100;
      }

      toggleFullscreen() {
        const container = document.getElementById('playerContainer');
        
        if (!document.fullscreenElement && !document.webkitFullscreenElement) {
          // Enter fullscreen
          if (container.requestFullscreen) {
            container.requestFullscreen();
          } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
          }
          
          // Request landscape orientation on mobile
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(() => {
              console.log('Orientation lock not supported');
            });
          }
          
          document.getElementById('fullscreenBtn').innerHTML = '<i class="fas fa-compress"></i>';
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          }
          
          // Unlock orientation
          if (screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
          }
          
          document.getElementById('fullscreenBtn').innerHTML = '<i class="fas fa-expand"></i>';
        }
      }

      playNext() {
        const currentIndex = this.episodes.findIndex(ep => ep.id === this.currentEpisode.id);
        if (currentIndex < this.episodes.length - 1) {
          const nextEpisode = this.episodes[currentIndex + 1];
          window.location.href = `player.html?showId=${this.showId}&episodeId=${nextEpisode.id}`;
        }
      }

      playPrevious() {
        const currentIndex = this.episodes.findIndex(ep => ep.id === this.currentEpisode.id);
        if (currentIndex > 0) {
          const prevEpisode = this.episodes[currentIndex - 1];
          window.location.href = `player.html?showId=${this.showId}&episodeId=${prevEpisode.id}`;
        }
      }

      updateNavigation() {
        const currentIndex = this.episodes.findIndex(ep => ep.id === this.currentEpisode.id);
        const prevBtn = document.getElementById('prevEpisodeBtn');
        const nextBtn = document.getElementById('nextEpisodeBtn');
        
        if (prevBtn) prevBtn.disabled = currentIndex === 0;
        if (nextBtn) nextBtn.disabled = currentIndex === this.episodes.length - 1;
      }

      showControls() {
        const controls = document.getElementById('playerControls');
        const topControls = document.getElementById('topControls');
        
        controls.classList.add('show');
        topControls.classList.add('show');
        
        clearTimeout(this.controlsTimeout);
        
        // Auto-hide after 3 seconds if playing
        this.controlsTimeout = setTimeout(() => {
          if (this.isPlaying && 
              !document.getElementById('settingsMenu').classList.contains('show') && 
              !document.getElementById('episodesListOverlay').classList.contains('show')) {
            this.hideControls();
          }
        }, 3000);
      }

      hideControls() {
        const controls = document.getElementById('playerControls');
        const topControls = document.getElementById('topControls');
        
        // Don't hide if menus are open
        if (!document.getElementById('settingsMenu').classList.contains('show') && 
            !document.getElementById('episodesListOverlay').classList.contains('show')) {
          controls.classList.remove('show');
          topControls.classList.remove('show');
        }
      }

      formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return '0:00';
        
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        
        if (h > 0) {
          return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }
        return `${m}:${s.toString().padStart(2, '0')}`;
      }
    }

    // Initialize player
    new NetflixPlayer();
  </script>
</body>
</html>